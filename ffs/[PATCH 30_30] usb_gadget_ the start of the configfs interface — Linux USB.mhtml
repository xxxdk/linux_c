From: <Saved by Blink>
Snapshot-Content-Location: https://www.spinics.net/lists/linux-usb/msg76388.html
Subject: =?utf-8?Q?[PATCH=2030/30]=20usb/gadget:=20the=20start=20of=20the=20config?=
 =?utf-8?Q?fs=20interface=20=E2=80=94=20Linux=20USB?=
Date: Sun, 26 May 2019 15:33:34 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--ArzVZrXEILSAOfWYeUefhfpv5l7ZR3rZdqEfzbYOA1----"


------MultipartBoundary--ArzVZrXEILSAOfWYeUefhfpv5l7ZR3rZdqEfzbYOA1----
Content-Type: text/html
Content-ID: <frame-325E2040E80D62A9107AADBEF65887AD@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://www.spinics.net/lists/linux-usb/msg76388.html

<!-- MHonArc v2.6.19 --><!--X-Subject: [PATCH 30/30] usb/gadget: the start =
of the configfs interface --><!--X-From-R13: Eronfgvna Oaqemrw Evrjvbe &#60=
;ovtrnflNyvahgebavk.qr> --><!--X-Date: Sun, 23 Dec 2012 12:13:36 &#45;0800 =
--><!--X-Message-Id: 1356293424&#45;21386&#45;31&#45;git&#45;send&#45;email=
&#45;bigeasy@linutronix.de --><!--X-Content-Type: text/plain --><!--X-Refer=
ence: 1356293424&#45;21386&#45;1&#45;git&#45;send&#45;email&#45;bigeasy@lin=
utronix.de --><!--X-Head-End--><!DOCTYPE html PUBLIC "-//W3C//DTD HTML//EN"=
><html><head><meta http-equiv=3D"Content-Type" content=3D"text/html; charse=
t=3DUTF-8">


<meta name=3D"viewport" content=3D"width=3Ddevice-width, initial-scale=3D1"=
>
<meta name=3D"description" content=3D"USB for Linux: [PATCH 30/30] usb/gadg=
et: the start of the configfs interface">
<style>
<!--
 pre {white-space: pre-wrap;}
-->
</style>
<title>[PATCH 30/30] usb/gadget: the start of the configfs interface =E2=80=
=94 Linux USB</title>
<link rel=3D"alternate" type=3D"application/rss+xml" title=3D"Linux USB" hr=
ef=3D"https://feedproxy.google.com/LinuxUsb">
</head>
<body itemscope=3D"" itemtype=3D"//schema.org/Article" bgcolor=3D"white" vl=
ink=3D"green" link=3D"blue">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<form action=3D"https://www.google.com/" id=3D"cse-search-box" target=3D"_b=
lank">
  <div>
   =20
   =20
    <input type=3D"text" name=3D"q" size=3D"25" placeholder=3D"Custom Searc=
h" style=3D"border: 1px solid rgb(126, 157, 185); padding: 2px; background:=
 url(&quot;https://www.google.com/cse/static/images/1x/googlelogo_lightgrey=
_46x16dp.png&quot;) left center no-repeat rgb(255, 255, 255); text-indent: =
48px;">
    <input type=3D"submit" name=3D"sa" value=3D"Search">
  </div>
</form>

<h1 itemprop=3D"name">[PATCH 30/30] usb/gadget: the start of the configfs i=
nterface</h1>
[<a href=3D"https://www.spinics.net/lists/linux-usb/msg76387.html">Date Pre=
v</a>][<a href=3D"https://www.spinics.net/lists/linux-usb/msg76389.html">Da=
te Next</a>][<a href=3D"https://www.spinics.net/lists/linux-usb/msg78752.ht=
ml">Thread Prev</a>][<a href=3D"https://www.spinics.net/lists/linux-usb/msg=
77428.html">Thread Next</a>][<a href=3D"https://www.spinics.net/lists/linux=
-usb/mail184.html#76388">Date Index</a>][<a href=3D"https://www.spinics.net=
/lists/linux-usb/thrd183.html#76388">Thread Index</a>]=20


<p>&nbsp;<br>

<!-- responsive test for archives -->
<ins class=3D"adsbygoogle" style=3D"display:block" data-ad-client=3D"ca-pub=
-3422782820843221" data-ad-slot=3D"6345952567" data-ad-format=3D"auto"></in=
s>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
</p><hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>Subject</em>: [PATCH 30/30] usb/gadget: the start of the configfs i=
nterface</li>
<li><em>From</em>: Sebastian Andrzej Siewior &lt;<a href=3D"mailto:bigeasy@=
DOMAIN.HIDDEN">bigeasy@xxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 23 Dec 2012 21:10:24 +0100</li>
<li><em>Cc</em>: <a href=3D"mailto:linux-usb@DOMAIN.HIDDEN">linux-usb@xxxxx=
xxxxxxxxxx</a>, <a href=3D"mailto:andrzej.p@DOMAIN.HIDDEN">andrzej.p@xxxxxx=
xxxxx</a>,        Sebastian Andrzej Siewior &lt;<a href=3D"mailto:bigeasy@D=
OMAIN.HIDDEN">bigeasy@xxxxxxxxxxxxx</a>&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href=3D"https://www.spinics.net/lists/linu=
x-usb/msg76378.html">1356293424-21386-1-git-send-email-bigeasy@linutronix.d=
e</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<!-- AddThis Button BEGIN -->
<div class=3D"addthis_toolbox addthis_default_style ">
<a class=3D"addthis_button_preferred_1"></a>
<a class=3D"addthis_button_preferred_2"></a>
<a class=3D"addthis_button_preferred_3"></a>
<a class=3D"addthis_button_preferred_4"></a>
<a class=3D"addthis_button_compact"></a>
<a class=3D"addthis_counter addthis_bubble_style"></a>
</div>

<!-- AddThis Button END -->
<hr>

<!-- responsive link 1 -->
<ins class=3D"adsbygoogle" style=3D"display:block" data-ad-client=3D"ca-pub=
-3422782820843221" data-ad-slot=3D"8681825769" data-ad-format=3D"link"></in=
s>

<p>
</p><div class=3D"content" itemprop=3D"articleBody">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>|# modprobe dummy_hcd num=3D2
|# modprobe libcomposite

|# lsmod
|Module                  Size  Used by
|libcomposite           31648  0
|dummy_hcd              19871  0

|# mkdir /sys/kernel/config/usb_gadget/oha
|# cd /sys/kernel/config/usb_gadget/oha
|# mkdir configs/def.1
|# mkdir configs/def.2
|# mkdir functions/acm.ttyS1
|# mkdir strings/0x1
|mkdir: cannot create directory `strings/0x1': Invalid argument
|# mkdir strings/0x409
|# mkdir strings/1033
|mkdir: cannot create directory `strings/1033': File exists
|# mkdir strings/1032
|# mkdir configs/def.1/strings/0x409
|# mkdir configs/def.2/strings/0x409

|#find . -ls
|   975    0 drwxr-xr-x   5 root     root            0 Dec 23 17:40 .
|   978    0 drwxr-xr-x   4 root     root            0 Dec 23 17:43 ./strin=
gs
|  4100    0 drwxr-xr-x   2 root     root            0 Dec 23 17:43 ./strin=
gs/1032
|   995    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strin=
gs/1032/serialnumber
|   996    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strin=
gs/1032/product
|   997    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strin=
gs/1032/manufacturer
|  2002    0 drwxr-xr-x   2 root     root            0 Dec 23 17:41 ./strin=
gs/0x409
|   998    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strin=
gs/0x409/serialnumber
|   999    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strin=
gs/0x409/product
|  1000    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strin=
gs/0x409/manufacturer
|   977    0 drwxr-xr-x   4 root     root            0 Dec 23 17:41 ./confi=
gs
|  4081    0 drwxr-xr-x   3 root     root            0 Dec 23 17:41 ./confi=
gs/def.2
|  4082    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 ./confi=
gs/def.2/strings
|  2016    0 drwxr-xr-x   2 root     root            0 Dec 23 17:42 ./confi=
gs/def.2/strings/0x409
|  1001    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./confi=
gs/def.2/strings/0x409/configuration
|  1002    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./confi=
gs/def.2/bmAttributes
|  1003    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./confi=
gs/def.2/MaxPower
|   979    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 ./confi=
gs/def.1
|   980    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 ./confi=
gs/def.1/strings
|  5122    0 drwxr-xr-x   2 root     root            0 Dec 23 17:42 ./confi=
gs/def.1/strings/0x409
|  1004    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./confi=
gs/def.1/strings/0x409/configuration
|  1005    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./confi=
gs/def.1/bmAttributes
|  1006    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./confi=
gs/def.1/MaxPower
|   976    0 drwxr-xr-x   3 root     root            0 Dec 23 17:41 ./funct=
ions
|   981    0 drwxr-xr-x   2 root     root            0 Dec 23 17:41 ./funct=
ions/acm.ttyS1
|  1007    0 -r--r--r--   1 root     root         4096 Dec 23 17:43 ./funct=
ions/acm.ttyS1/port_num
|  1008    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./UDC
|  1009    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bcdUS=
B
|  1010    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bcdDe=
vice
|  1011    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./idPro=
duct
|  1012    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./idVen=
dor
|  1013    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bMaxP=
acketSize0
|  1014    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bDevi=
ceProtocol
|  1015    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bDevi=
ceSubClass
|  1016    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bDevi=
ceClass

|# cat functions/acm.ttyS1/port_num
|0
|# ls -lah /dev/ttyGS*
|crw-rw---T 1 root dialout 252, 0 Dec 23 17:41 /dev/ttyGS0
|
|# echo 0x1234 &gt; idProduct
|# echo 0xabcd &gt; idVendor
|# echo 1122 &gt; strings/0x409/serialnumber
|# echo "The manufacturer" &gt; strings/0x409/manufacturer
|# echo 1 &gt; strings/1032/manufacturer
|# echo 1sa &gt; strings/1032/product
|# echo tada &gt; strings/1032/serialnumber
|echo "Primary configuration" &gt; configs/def.1/strings/0x409/configuratio=
n
|# echo "Secondary configuration" &gt; configs/def.2/strings/0x409/configur=
ation
|# ln -s functions/acm.ttyS1 configs/def.1/
|# ln -s functions/acm.ttyS1 configs/def.2/
|find configs/def.1/ -ls
|   979    0 drwxr-xr-x   3 root     root            0 Dec 23 17:49 configs=
/def.1/
|  6264    0 lrwxrwxrwx   1 root     root            0 Dec 23 17:48 configs=
/def.1/acm.ttyS1 -&gt; ../../../../usb_gadget/oha/functions/acm.ttyS1
|   980    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 configs=
/def.1/strings
|  5122    0 drwxr-xr-x   2 root     root            0 Dec 23 17:49 configs=
/def.1/strings/0x409
|  6284    0 -rw-r--r--   1 root     root         4096 Dec 23 17:47 configs=
/def.1/strings/0x409/configuration
|  6285    0 -rw-r--r--   1 root     root         4096 Dec 23 17:49 configs=
/def.1/bmAttributes
|  6286    0 -rw-r--r--   1 root     root         4096 Dec 23 17:49 configs=
/def.1/MaxPower
|
|echo 120 &gt; configs/def.1/MaxPower
|
|# ls -lh /sys/class/udc/
|total 0
|lrwxrwxrwx 1 root root 0 Dec 23 17:50 dummy_udc.0 -&gt; ../../devices/plat=
form/dummy_udc.0/udc/dummy_udc.0
|lrwxrwxrwx 1 root root 0 Dec 23 17:50 dummy_udc.1 -&gt; ../../devices/plat=
form/dummy_udc.1/udc/dummy_udc.1
|# echo dummy_udc.0 &gt; UDC
|# lsusb
|Bus 001 Device 002: ID abcd:1234 Unknown
|
|lsusb -d abcd:1234 -v
|Device Descriptor:
=E2=80=A6
|  idVendor           0xabcd Unknown
|  idProduct          0x1234
|  bcdDevice            3.06
|  iManufacturer           1 The manufacturer
|  iProduct                2
|  iSerial                 3 1122
|  bNumConfigurations      2
=E2=80=A6
|echo "" &gt; UDC

v5=E2=80=A6v6
- wired up strings with usb_gstrings_attach()
- add UDC attribe. Write "udc-name" will bind the gadget. Write an empty
  string (it should contain \n since 0 bytes write get optimzed away)
  will unbind the UDC from the gadget. The name of available UDCs can be
  obtained from /sys/class/udc/

v4=E2=80=A6v5
- string rework. This will add a strings folder incl. language code like
    strings/409/manufacturer
  as suggested by Alan.
- rebased ontop reworked functions.c which has usb_function_instance
  which is used prior after "mkdir acm.instance" and can be directly
  used for configuration via configfs.

v3=E2=80=A6v4
 - moved functions from the root folde down to the gadget as suggested
   by Micha=C5=82
 - configs have now their own configs folder as suggested by Micha=C5=82.
   The folder is still name.bConfigurationValue where name becomes the
   sConfiguration. Is this usefull should we just stilc
   configs/bConfigurationValue/ ?
 - added configfs support to the ACM function. The port_num attribute is
   exported by f_acm. An argument has been added to the USB alloc
   function to distinguish between "old" (use facm_configure() to
   configure and configfs interface (expose a config_node).
   The port_num is currently a dumb counter. It will
   require some function re-work to make it work.

scheduled for v5:
- sym linking function into config.

v2=E2=80=A6v3
- replaced one ifndef by ifdef as suggested by Micaha=C5=82
- strstr()/strchr() function_make as suggested by Micah=C5=82
- replace [iSerialNumber|iProduct|iManufacturer] with
  [sSerialNumber|sProduct|sManufacturer] as suggested by Alan
- added creation of config descriptors

v1=E2=80=A6v2
- moved gadgets from configfs' root directory into /udcs/ within our
  "usb_gadget" folder. Requested by Andrzej &amp; Micha=C5=82
- use a dot as a delimiter between function's name and its instance's name
  as suggested by Micha=C5=82
- renamed all config_item_type, configfs_group_operations, make_group,
  drop_item as suggested by suggested by Andrzej to remain consisten
  within this file and within other configfs users
- Since configfs.c and functions.c are now part of the udc-core module,
  the module itself is now called udc. Also added a tiny ifdef around
  init code becuase udc-core is subsys init and this is too early for
  configfs in the built-in case. In the module case, we can only have
  one init function.

Signed-off-by: Sebastian Andrzej Siewior &lt;bigeasy@xxxxxxxxxxxxx&gt;
---
 drivers/usb/gadget/Kconfig          |    1 +
 drivers/usb/gadget/Makefile         |    2 +-
 drivers/usb/gadget/composite.c      |    1 +
 drivers/usb/gadget/configfs.c       | 1003 +++++++++++++++++++++++++++++++=
++++
 drivers/usb/gadget/f_acm.c          |   55 ++
 include/linux/usb/composite.h       |    3 +
 include/linux/usb/gadget_configfs.h |  110 ++++
 7 files changed, 1174 insertions(+), 1 deletion(-)
 create mode 100644 drivers/usb/gadget/configfs.c
 create mode 100644 include/linux/usb/gadget_configfs.h

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index afb78f6..e8d2f8e 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -498,6 +498,7 @@ endmenu
 # composite based drivers
 config USB_LIBCOMPOSITE
 	tristate
+	select CONFIGFS_FS
 	depends on USB_GADGET
=20
 config USB_F_ACM
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 97a13c3..070eb33 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -6,7 +6,7 @@ ccflags-$(CONFIG_USB_GADGET_DEBUG) :=3D -DDEBUG
 obj-$(CONFIG_USB_GADGET)	+=3D udc-core.o
 obj-$(CONFIG_USB_LIBCOMPOSITE)	+=3D libcomposite.o
 libcomposite-y			:=3D usbstring.o config.o epautoconf.o
-libcomposite-y			+=3D composite.o functions.o
+libcomposite-y			+=3D composite.o functions.o configfs.o
 obj-$(CONFIG_USB_DUMMY_HCD)	+=3D dummy_hcd.o
 obj-$(CONFIG_USB_NET2272)	+=3D net2272.o
 obj-$(CONFIG_USB_NET2280)	+=3D net2280.o
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.=
c
index 7c821de..f7c0e6b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1637,6 +1637,7 @@ void composite_dev_cleanup(struct usb_composite_dev *=
cdev)
 		kfree(cdev-&gt;req-&gt;buf);
 		usb_ep_free_request(cdev-&gt;gadget-&gt;ep0, cdev-&gt;req);
 	}
+	cdev-&gt;next_string_id =3D 0;
 	device_remove_file(&amp;cdev-&gt;gadget-&gt;dev, &amp;dev_attr_suspended)=
;
 }
=20
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
new file mode 100644
index 0000000..a34633a
--- /dev/null
+++ b/drivers/usb/gadget/configfs.c
@@ -0,0 +1,1003 @@
+#include &lt;linux/configfs.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/device.h&gt;
+#include &lt;linux/usb/composite.h&gt;
+#include &lt;linux/usb/gadget_configfs.h&gt;
+
+int check_user_usb_string(const char *name,
+		struct usb_gadget_strings *stringtab_dev)
+{
+	unsigned primary_lang;
+	unsigned sub_lang;
+	u16 num;
+	int ret;
+
+	ret =3D kstrtou16(name, 0, &amp;num);
+	if (ret)
+		return ret;
+
+	primary_lang =3D num &amp; 0x3ff;
+	sub_lang =3D num &gt;&gt; 10;
+
+	/* simple sanity check for valid langid */
+	switch (primary_lang) {
+	case 0:
+	case 0x62 ... 0xfe:
+	case 0x100 ... 0x3ff:
+		return -EINVAL;
+	}
+	if (!sub_lang)
+		return -EINVAL;
+
+	stringtab_dev-&gt;language =3D num;
+	return 0;
+}
+
+#define MAX_NAME_LEN	40
+#define MAX_USB_STRING_LANGS 2
+
+struct gadget_info {
+	struct config_group group;
+	struct config_group functions_group;
+	struct config_group configs_group;
+	struct config_group strings_group;
+	struct config_group *default_groups[4];
+
+	struct mutex lock;
+	struct usb_gadget_strings *gstrings[MAX_USB_STRING_LANGS + 1];
+	struct list_head string_list;
+	struct list_head available_func;
+
+	const char *udc_name;
+#ifdef CONFIG_USB_OTG
+	struct usb_otg_descriptor otg;
+#endif
+	struct usb_composite_driver composite;
+	struct usb_composite_dev cdev;
+};
+
+struct config_usb_cfg {
+	struct config_group group;
+	struct config_group strings_group;
+	struct config_group *default_groups[2];
+	struct list_head string_list;
+	struct usb_configuration c;
+	struct list_head func_list;
+	struct usb_gadget_strings *gstrings[MAX_USB_STRING_LANGS + 1];
+};
+
+struct gadget_strings {
+	struct usb_gadget_strings stringtab_dev;
+	struct usb_string strings[USB_GADGET_FIRST_AVAIL_IDX];
+	char *manufacturer;
+	char *product;
+	char *serialnumber;
+
+	struct config_group group;
+	struct list_head list;
+};
+
+struct gadget_config_name {
+	struct usb_gadget_strings stringtab_dev;
+	struct usb_string strings;
+	char *configuration;
+
+	struct config_group group;
+	struct list_head list;
+};
+
+static int usb_string_copy(const char *s, char **s_copy)
+{
+	int ret;
+	char *str;
+	char *copy =3D *s_copy;
+	ret =3D strlen(s);
+	if (ret &gt; 126)
+		return -EOVERFLOW;
+
+	str =3D kstrdup(s, GFP_KERNEL);
+	if (!str)
+		return -ENOMEM;
+	if (str[ret - 1] =3D=3D '\n')
+		str[ret - 1] =3D '\0';
+	kfree(copy);
+	*s_copy =3D str;
+	return 0;
+}
+
+CONFIGFS_ATTR_STRUCT(gadget_info);
+CONFIGFS_ATTR_STRUCT(config_usb_cfg);
+
+#define GI_DEVICE_DESC_ITEM_ATTR(name)	\
+	static struct gadget_info_attribute gadget_cdev_desc_##name =3D \
+		__CONFIGFS_ATTR(name,  S_IRUGO | S_IWUSR,		\
+				gadget_dev_desc_##name##_show,		\
+				gadget_dev_desc_##name##_store)
+
+#define GI_DEVICE_DESC_SIMPLE_R_u8(__name)	\
+	static ssize_t gadget_dev_desc_##__name##_show(struct gadget_info *gi, \
+			char *page)	\
+{	\
+	return sprintf(page, "0x%02x\n", gi-&gt;cdev.desc.__name);	\
+}
+
+#define GI_DEVICE_DESC_SIMPLE_R_u16(__name)	\
+	static ssize_t gadget_dev_desc_##__name##_show(struct gadget_info *gi, \
+			char *page)	\
+{	\
+	return sprintf(page, "0x%04x\n", le16_to_cpup(&amp;gi-&gt;cdev.desc.__nam=
e)); \
+}
+
+
+#define GI_DEVICE_DESC_SIMPLE_W_u8(_name)		\
+	static ssize_t gadget_dev_desc_##_name##_store(struct gadget_info *gi, \
+		const char *page, size_t len)		\
+{							\
+	u8 val;						\
+	int ret;					\
+	ret =3D kstrtou8(page, 0, &amp;val);			\
+	if (ret)					\
+		return ret;				\
+	gi-&gt;cdev.desc._name =3D val;			\
+	return len;					\
+}
+
+#define GI_DEVICE_DESC_SIMPLE_W_u16(_name)	\
+	static ssize_t gadget_dev_desc_##_name##_store(struct gadget_info *gi, \
+		const char *page, size_t len)		\
+{							\
+	u16 val;					\
+	int ret;					\
+	ret =3D kstrtou16(page, 0, &amp;val);			\
+	if (ret)					\
+		return ret;				\
+	gi-&gt;cdev.desc._name =3D cpu_to_le16p(&amp;val);	\
+	return len;					\
+}
+
+#define GI_DEVICE_DESC_SIMPLE_RW(_name, _type)	\
+	GI_DEVICE_DESC_SIMPLE_R_##_type(_name)	\
+	GI_DEVICE_DESC_SIMPLE_W_##_type(_name)
+
+GI_DEVICE_DESC_SIMPLE_R_u16(bcdUSB);
+GI_DEVICE_DESC_SIMPLE_RW(bDeviceClass, u8);
+GI_DEVICE_DESC_SIMPLE_RW(bDeviceSubClass, u8);
+GI_DEVICE_DESC_SIMPLE_RW(bDeviceProtocol, u8);
+GI_DEVICE_DESC_SIMPLE_RW(bMaxPacketSize0, u8);
+GI_DEVICE_DESC_SIMPLE_RW(idVendor, u16);
+GI_DEVICE_DESC_SIMPLE_RW(idProduct, u16);
+GI_DEVICE_DESC_SIMPLE_R_u16(bcdDevice);
+
+static ssize_t is_valid_bcd(u16 bcd_val)
+{
+	if ((bcd_val &amp; 0xf) &gt; 9)
+		return -EINVAL;
+	if (((bcd_val &gt;&gt; 4) &amp; 0xf) &gt; 9)
+		return -EINVAL;
+	if (((bcd_val &gt;&gt; 8) &amp; 0xf) &gt; 9)
+		return -EINVAL;
+	if (((bcd_val &gt;&gt; 12) &amp; 0xf) &gt; 9)
+		return -EINVAL;
+	return 0;
+}
+
+static ssize_t gadget_dev_desc_bcdDevice_store(struct gadget_info *gi,
+		const char *page, size_t len)
+{
+	u16 bcdDevice;
+	int ret;
+
+	ret =3D kstrtou16(page, 0, &amp;bcdDevice);
+	if (ret)
+		return ret;
+	ret =3D is_valid_bcd(bcdDevice);
+	if (ret)
+		return ret;
+
+	gi-&gt;cdev.desc.bcdDevice =3D cpu_to_le16(bcdDevice);
+	return len;
+}
+
+static ssize_t gadget_dev_desc_bcdUSB_store(struct gadget_info *gi,
+		const char *page, size_t len)
+{
+	u16 bcdUSB;
+	int ret;
+
+	ret =3D kstrtou16(page, 0, &amp;bcdUSB);
+	if (ret)
+		return ret;
+	ret =3D is_valid_bcd(bcdUSB);
+	if (ret)
+		return ret;
+
+	gi-&gt;cdev.desc.bcdUSB =3D cpu_to_le16(bcdUSB);
+	return len;
+}
+
+static ssize_t gadget_dev_desc_UDC_show(struct gadget_info *gi, char *page=
)
+{
+	return sprintf(page, "%s\n", gi-&gt;udc_name ?: "");
+}
+
+static int unregister_gadget(struct gadget_info *gi)
+{
+	int ret;
+
+	if (!gi-&gt;udc_name)
+		return -ENODEV;
+
+	ret =3D usb_gadget_unregister_driver(&amp;gi-&gt;composite.gadget_driver)=
;
+	if (ret)
+		return ret;
+	kfree(gi-&gt;udc_name);
+	gi-&gt;udc_name =3D NULL;
+	return 0;
+}
+
+static ssize_t gadget_dev_desc_UDC_store(struct gadget_info *gi,
+		const char *page, size_t len)
+{
+	char *name;
+	int ret;
+
+	name =3D kstrdup(page, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+	if (name[len - 1] =3D=3D '\n')
+		name[len - 1] =3D '\0';
+
+	mutex_lock(&amp;gi-&gt;lock);
+
+	if (!strlen(name)) {
+		ret =3D unregister_gadget(gi);
+		if (ret)
+			goto err;
+	} else {
+		if (gi-&gt;udc_name) {
+			ret =3D -EBUSY;
+			goto err;
+		}
+		ret =3D udc_attach_driver(name, &amp;gi-&gt;composite.gadget_driver);
+		if (ret)
+			goto err;
+		gi-&gt;udc_name =3D name;
+	}
+	mutex_unlock(&amp;gi-&gt;lock);
+	return len;
+err:
+	kfree(name);
+	mutex_unlock(&amp;gi-&gt;lock);
+	return ret;
+}
+
+GI_DEVICE_DESC_ITEM_ATTR(bDeviceClass);
+GI_DEVICE_DESC_ITEM_ATTR(bDeviceSubClass);
+GI_DEVICE_DESC_ITEM_ATTR(bDeviceProtocol);
+GI_DEVICE_DESC_ITEM_ATTR(bMaxPacketSize0);
+GI_DEVICE_DESC_ITEM_ATTR(idVendor);
+GI_DEVICE_DESC_ITEM_ATTR(idProduct);
+GI_DEVICE_DESC_ITEM_ATTR(bcdDevice);
+GI_DEVICE_DESC_ITEM_ATTR(bcdUSB);
+GI_DEVICE_DESC_ITEM_ATTR(UDC);
+
+static struct configfs_attribute *gadget_root_attrs[] =3D {
+	&amp;gadget_cdev_desc_bDeviceClass.attr,
+	&amp;gadget_cdev_desc_bDeviceSubClass.attr,
+	&amp;gadget_cdev_desc_bDeviceProtocol.attr,
+	&amp;gadget_cdev_desc_bMaxPacketSize0.attr,
+	&amp;gadget_cdev_desc_idVendor.attr,
+	&amp;gadget_cdev_desc_idProduct.attr,
+	&amp;gadget_cdev_desc_bcdDevice.attr,
+	&amp;gadget_cdev_desc_bcdUSB.attr,
+	&amp;gadget_cdev_desc_UDC.attr,
+	NULL,
+};
+
+static inline struct gadget_info *to_gadget_info(struct config_item *item)
+{
+	 return container_of(to_config_group(item), struct gadget_info, group);
+}
+
+static inline struct gadget_strings *to_gadget_strings(struct config_item =
*item)
+{
+	 return container_of(to_config_group(item), struct gadget_strings,
+			 group);
+}
+
+static inline struct gadget_config_name *to_gadget_config_name(
+		struct config_item *item)
+{
+	 return container_of(to_config_group(item), struct gadget_config_name,
+			 group);
+}
+
+static inline struct config_usb_cfg *to_config_usb_cfg(struct config_item =
*item)
+{
+	return container_of(to_config_group(item), struct config_usb_cfg,
+			group);
+}
+
+static inline struct usb_function_instance *to_usb_function_instance(
+		struct config_item *item)
+{
+	 return container_of(to_config_group(item),
+			 struct usb_function_instance, group);
+}
+
+static void gadget_info_attr_release(struct config_item *item)
+{
+	struct gadget_info *gi =3D to_gadget_info(item);
+
+	WARN_ON(!list_empty(&amp;gi-&gt;cdev.configs));
+	WARN_ON(!list_empty(&amp;gi-&gt;string_list));
+	WARN_ON(!list_empty(&amp;gi-&gt;available_func));
+	kfree(gi-&gt;composite.gadget_driver.function);
+	kfree(gi);
+}
+
+CONFIGFS_ATTR_OPS(gadget_info);
+
+static struct configfs_item_operations gadget_root_item_ops =3D {
+	.release                =3D gadget_info_attr_release,
+	.show_attribute         =3D gadget_info_attr_show,
+	.store_attribute        =3D gadget_info_attr_store,
+};
+
+static void gadget_config_attr_release(struct config_item *item)
+{
+	struct config_usb_cfg *cfg =3D to_config_usb_cfg(item);
+
+	WARN_ON(!list_empty(&amp;cfg-&gt;c.functions));
+	list_del(&amp;cfg-&gt;c.list);
+	kfree(cfg-&gt;c.label);
+	kfree(cfg);
+}
+
+static int config_usb_cfg_link(
+	struct config_item *usb_cfg_ci,
+	struct config_item *usb_func_ci)
+{
+	struct config_usb_cfg *cfg =3D to_config_usb_cfg(usb_cfg_ci);
+	struct usb_composite_dev *cdev =3D cfg-&gt;c.cdev;
+	struct gadget_info *gi =3D container_of(cdev, struct gadget_info, cdev);
+
+	struct config_group *group =3D to_config_group(usb_func_ci);
+	struct usb_function_instance *fi =3D container_of(group,
+			struct usb_function_instance, group);
+	struct usb_function_instance *a_fi;
+	struct usb_function *f;
+	int ret;
+
+	mutex_lock(&amp;gi-&gt;lock);
+	/*
+	 * Make sure this function is from within our _this_ gadget and not
+	 * from another gadget or a random directory.
+	 * Also a function instance can only be linked once.
+	 */
+	list_for_each_entry(a_fi, &amp;gi-&gt;available_func, cfs_list) {
+		if (a_fi =3D=3D fi)
+			break;
+	}
+	if (a_fi !=3D fi) {
+		ret =3D -EINVAL;
+		goto out;
+	}
+
+	list_for_each_entry(f, &amp;cfg-&gt;func_list, list) {
+		if (f-&gt;fi =3D=3D fi) {
+			ret =3D -EEXIST;
+			goto out;
+		}
+	}
+
+	f =3D usb_get_function(fi);
+	if (IS_ERR(f)) {
+		ret =3D PTR_ERR(f);
+		goto out;
+	}
+
+	/* stash the function until we bind it to the gadget */
+	list_add_tail(&amp;f-&gt;list, &amp;cfg-&gt;func_list);
+	ret =3D 0;
+out:
+	mutex_unlock(&amp;gi-&gt;lock);
+	return ret;
+}
+
+static int config_usb_cfg_unlink(
+	struct config_item *usb_cfg_ci,
+	struct config_item *usb_func_ci)
+{
+	struct config_usb_cfg *cfg =3D to_config_usb_cfg(usb_cfg_ci);
+	struct usb_composite_dev *cdev =3D cfg-&gt;c.cdev;
+	struct gadget_info *gi =3D container_of(cdev, struct gadget_info, cdev);
+
+	struct config_group *group =3D to_config_group(usb_func_ci);
+	struct usb_function_instance *fi =3D container_of(group,
+			struct usb_function_instance, group);
+	struct usb_function *f;
+
+	/*
+	 * ideally I would like to forbid to unlink functions while a gadget is
+	 * bound to an UDC. Since this isn't possible at the moment, we simply
+	 * force an unbind, the function is available here and then we can
+	 * remove the function.
+	 */
+	mutex_lock(&amp;gi-&gt;lock);
+	if (gi-&gt;udc_name)
+		unregister_gadget(gi);
+	WARN_ON(gi-&gt;udc_name);
+
+	list_for_each_entry(f, &amp;cfg-&gt;func_list, list) {
+		if (f-&gt;fi =3D=3D fi) {
+			list_del(&amp;f-&gt;list);
+			usb_put_function(f);
+			mutex_unlock(&amp;gi-&gt;lock);
+			return 0;
+		}
+	}
+	mutex_unlock(&amp;gi-&gt;lock);
+	__WARN_printf("Unable to locate function to unbind\n");
+	return 0;
+}
+
+CONFIGFS_ATTR_OPS(config_usb_cfg);
+
+static struct configfs_item_operations gadget_config_item_ops =3D {
+	.release                =3D gadget_config_attr_release,
+	.show_attribute         =3D config_usb_cfg_attr_show,
+	.store_attribute        =3D config_usb_cfg_attr_store,
+	.allow_link             =3D config_usb_cfg_link,
+	.drop_link              =3D config_usb_cfg_unlink,
+};
+
+
+static ssize_t gadget_config_desc_MaxPower_show(struct config_usb_cfg *cfg=
,
+		char *page)
+{
+	return sprintf(page, "%u\n", cfg-&gt;c.MaxPower);
+}
+
+static ssize_t gadget_config_desc_MaxPower_store(struct config_usb_cfg *cf=
g,
+		const char *page, size_t len)
+{
+	u16 val;
+	int ret;
+	ret =3D kstrtou16(page, 0, &amp;val);
+	if (ret)
+		return ret;
+	if (DIV_ROUND_UP(val, 8) &gt; 0xff)
+		return -ERANGE;
+	cfg-&gt;c.MaxPower =3D val;
+	return len;
+}
+
+static ssize_t gadget_config_desc_bmAttributes_show(struct config_usb_cfg =
*cfg,
+		char *page)
+{
+	return sprintf(page, "0x%02x\n", cfg-&gt;c.bmAttributes);
+}
+
+static ssize_t gadget_config_desc_bmAttributes_store(struct config_usb_cfg=
 *cfg,
+		const char *page, size_t len)
+{
+	u8 val;
+	int ret;
+	ret =3D kstrtou8(page, 0, &amp;val);
+	if (ret)
+		return ret;
+	if (!(val &amp; USB_CONFIG_ATT_ONE))
+		return -EINVAL;
+	if (val &amp; ~(USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER |
+				USB_CONFIG_ATT_WAKEUP))
+		return -EINVAL;
+	cfg-&gt;c.bmAttributes =3D val;
+	return len;
+}
+
+#define CFG_CONFIG_DESC_ITEM_ATTR(name)	\
+	static struct config_usb_cfg_attribute gadget_usb_cfg_##name =3D \
+		__CONFIGFS_ATTR(name,  S_IRUGO | S_IWUSR,		\
+				gadget_config_desc_##name##_show,	\
+				gadget_config_desc_##name##_store)
+
+CFG_CONFIG_DESC_ITEM_ATTR(MaxPower);
+CFG_CONFIG_DESC_ITEM_ATTR(bmAttributes);
+
+static struct configfs_attribute *gadget_config_attrs[] =3D {
+	&amp;gadget_usb_cfg_MaxPower.attr,
+	&amp;gadget_usb_cfg_bmAttributes.attr,
+	NULL,
+};
+
+static struct config_item_type gadget_config_type =3D {
+	.ct_item_ops	=3D &amp;gadget_config_item_ops,
+	.ct_attrs	=3D gadget_config_attrs,
+	.ct_owner	=3D THIS_MODULE,
+};
+
+static struct config_item_type gadget_root_type =3D {
+	.ct_item_ops	=3D &amp;gadget_root_item_ops,
+	.ct_attrs	=3D gadget_root_attrs,
+	.ct_owner	=3D THIS_MODULE,
+};
+
+static void composite_init_dev(struct usb_composite_dev *cdev)
+{
+	spin_lock_init(&amp;cdev-&gt;lock);
+	INIT_LIST_HEAD(&amp;cdev-&gt;configs);
+	INIT_LIST_HEAD(&amp;cdev-&gt;gstrings);
+}
+
+static struct config_group *function_make(
+		struct config_group *group,
+		const char *name)
+{
+	struct gadget_info *gi;
+	struct usb_function_instance *fi;
+	char buf[MAX_NAME_LEN];
+	char *func_name;
+	char *instance_name;
+	int ret;
+
+	ret =3D snprintf(buf, MAX_NAME_LEN, "%s", name);
+	if (ret &gt;=3D MAX_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	func_name =3D buf;
+	instance_name =3D strchr(func_name, '.');
+	if (!instance_name) {
+		pr_err("Unable to locate . in FUNC.INSTANCE\n");
+		return ERR_PTR(-EINVAL);
+	}
+	*instance_name =3D '\0';
+	instance_name++;
+
+	fi =3D usb_get_function_instance(func_name);
+	if (IS_ERR(fi))
+		return ERR_PTR(PTR_ERR(fi));
+
+	ret =3D config_item_set_name(&amp;fi-&gt;group.cg_item, name);
+	if (ret) {
+		usb_put_function_instance(fi);
+		return ERR_PTR(ret);
+	}
+
+	gi =3D container_of(group, struct gadget_info, functions_group);
+
+	mutex_lock(&amp;gi-&gt;lock);
+	list_add_tail(&amp;fi-&gt;cfs_list, &amp;gi-&gt;available_func);
+	mutex_unlock(&amp;gi-&gt;lock);
+	return &amp;fi-&gt;group;
+}
+
+static void function_drop(
+		struct config_group *group,
+		struct config_item *item)
+{
+	struct usb_function_instance *fi =3D to_usb_function_instance(item);
+	struct gadget_info *gi;
+
+	gi =3D container_of(group, struct gadget_info, functions_group);
+
+	mutex_lock(&amp;gi-&gt;lock);
+	list_del(&amp;fi-&gt;cfs_list);
+	mutex_unlock(&amp;gi-&gt;lock);
+	config_item_put(item);
+}
+
+static struct configfs_group_operations functions_ops =3D {
+	.make_group     =3D &amp;function_make,
+	.drop_item      =3D &amp;function_drop,
+};
+
+static struct config_item_type functions_type =3D {
+	.ct_group_ops   =3D &amp;functions_ops,
+	.ct_owner       =3D THIS_MODULE,
+};
+
+CONFIGFS_ATTR_STRUCT(gadget_config_name);
+GS_STRINGS_RW(gadget_config_name, configuration);
+
+static struct configfs_attribute *gadget_config_name_langid_attrs[] =3D {
+	&amp;gadget_config_name_configuration.attr,
+	NULL,
+};
+
+static void gadget_config_name_attr_release(struct config_item *item)
+{
+	struct gadget_config_name *cn =3D to_gadget_config_name(item);
+
+	kfree(cn-&gt;configuration);
+
+	list_del(&amp;cn-&gt;list);
+	kfree(cn);
+}
+
+USB_CONFIG_STRING_RW_OPS(gadget_config_name);
+USB_CONFIG_STRINGS_LANG(gadget_config_name, config_usb_cfg);
+
+static struct config_group *config_desc_make(
+		struct config_group *group,
+		const char *name)
+{
+	struct gadget_info *gi;
+	struct config_usb_cfg *cfg;
+	char buf[MAX_NAME_LEN];
+	char *num_str;
+	u8 num;
+	int ret;
+
+	gi =3D container_of(group, struct gadget_info, configs_group);
+	ret =3D snprintf(buf, MAX_NAME_LEN, "%s", name);
+	if (ret &gt;=3D MAX_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	num_str =3D strchr(buf, '.');
+	if (!num_str) {
+		pr_err("Unable to locate . in name.bConfigurationValue\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	*num_str =3D '\0';
+	num_str++;
+
+	if (!strlen(buf))
+		return ERR_PTR(-EINVAL);
+
+	ret =3D kstrtou8(num_str, 0, &amp;num);
+	if (ret)
+		return ERR_PTR(ret);
+
+	cfg =3D kzalloc(sizeof(*cfg), GFP_KERNEL);
+	if (!cfg)
+		return ERR_PTR(-ENOMEM);
+	cfg-&gt;c.label =3D kstrdup(buf, GFP_KERNEL);
+	if (!cfg-&gt;c.label) {
+		ret =3D -ENOMEM;
+		goto err;
+	}
+	cfg-&gt;c.bConfigurationValue =3D num;
+	cfg-&gt;c.MaxPower =3D CONFIG_USB_GADGET_VBUS_DRAW;
+	cfg-&gt;c.bmAttributes =3D USB_CONFIG_ATT_ONE;
+	INIT_LIST_HEAD(&amp;cfg-&gt;string_list);
+	INIT_LIST_HEAD(&amp;cfg-&gt;func_list);
+
+	cfg-&gt;group.default_groups =3D cfg-&gt;default_groups;
+	cfg-&gt;default_groups[0] =3D &amp;cfg-&gt;strings_group;
+
+	config_group_init_type_name(&amp;cfg-&gt;group, name,
+				&amp;gadget_config_type);
+	config_group_init_type_name(&amp;cfg-&gt;strings_group, "strings",
+			&amp;gadget_config_name_strings_type);
+
+	ret =3D usb_add_config_only(&amp;gi-&gt;cdev, &amp;cfg-&gt;c);
+	if (ret)
+		goto err;
+
+	return &amp;cfg-&gt;group;
+err:
+	kfree(cfg-&gt;c.label);
+	kfree(cfg);
+	return ERR_PTR(ret);
+}
+
+static void config_desc_drop(
+		struct config_group *group,
+		struct config_item *item)
+{
+	config_item_put(item);
+}
+
+static struct configfs_group_operations config_desc_ops =3D {
+	.make_group     =3D &amp;config_desc_make,
+	.drop_item      =3D &amp;config_desc_drop,
+};
+
+static struct config_item_type config_desc_type =3D {
+	.ct_group_ops   =3D &amp;config_desc_ops,
+	.ct_owner       =3D THIS_MODULE,
+};
+
+CONFIGFS_ATTR_STRUCT(gadget_strings);
+GS_STRINGS_RW(gadget_strings, manufacturer);
+GS_STRINGS_RW(gadget_strings, product);
+GS_STRINGS_RW(gadget_strings, serialnumber);
+
+static struct configfs_attribute *gadget_strings_langid_attrs[] =3D {
+	&amp;gadget_strings_manufacturer.attr,
+	&amp;gadget_strings_product.attr,
+	&amp;gadget_strings_serialnumber.attr,
+	NULL,
+};
+
+static void gadget_strings_attr_release(struct config_item *item)
+{
+	struct gadget_strings *gs =3D to_gadget_strings(item);
+
+	kfree(gs-&gt;manufacturer);
+	kfree(gs-&gt;product);
+	kfree(gs-&gt;serialnumber);
+
+	list_del(&amp;gs-&gt;list);
+	kfree(gs);
+}
+
+USB_CONFIG_STRING_RW_OPS(gadget_strings);
+USB_CONFIG_STRINGS_LANG(gadget_strings, gadget_info);
+
+static int configfs_do_nothing(struct usb_composite_dev *cdev)
+{
+	__WARN();
+	return -EINVAL;
+}
+
+int composite_dev_prepare(struct usb_composite_driver *composite,
+		struct usb_composite_dev *dev);
+
+static void purge_configs_funcs(struct gadget_info *gi)
+{
+	struct usb_configuration	*c;
+
+	list_for_each_entry(c, &amp;gi-&gt;cdev.configs, list) {
+		struct usb_function *f, *tmp;
+		struct config_usb_cfg *cfg;
+
+		cfg =3D container_of(c, struct config_usb_cfg, c);
+
+		list_for_each_entry_safe(f, tmp, &amp;c-&gt;functions, list) {
+
+			list_move_tail(&amp;f-&gt;list, &amp;cfg-&gt;func_list);
+			if (f-&gt;unbind) {
+				dev_err(&amp;gi-&gt;cdev.gadget-&gt;dev, "unbind function"
+						" '%s'/%p\n", f-&gt;name, f);
+				f-&gt;unbind(c, f);
+			}
+		}
+		c-&gt;next_interface_id =3D 0;
+		c-&gt;superspeed =3D 0;
+		c-&gt;highspeed =3D 0;
+		c-&gt;fullspeed =3D 0;
+	}
+}
+
+static int configfs_composite_bind(struct usb_gadget *gadget,
+		struct usb_gadget_driver *gdriver)
+{
+	struct usb_composite_driver     *composite =3D to_cdriver(gdriver);
+	struct gadget_info		*gi =3D container_of(composite,
+						struct gadget_info, composite);
+	struct usb_composite_dev	*cdev =3D &amp;gi-&gt;cdev;
+	struct usb_configuration	*c;
+	struct usb_string		*s;
+	unsigned			i;
+	int				ret;
+
+	/* the gi-&gt;lock is hold by the caller */
+	cdev-&gt;gadget =3D gadget;
+	set_gadget_data(gadget, cdev);
+	ret =3D composite_dev_prepare(composite, cdev);
+	if (ret)
+		return ret;
+	/* and now the gadget bind */
+	ret =3D -EINVAL;
+
+	if (list_empty(&amp;gi-&gt;cdev.configs)) {
+		pr_err("Need atleast one configuration in %s.\n",
+				gi-&gt;composite.name);
+		goto err_comp_cleanup;
+	}
+
+
+	list_for_each_entry(c, &amp;gi-&gt;cdev.configs, list) {
+		struct config_usb_cfg *cfg;
+
+		cfg =3D container_of(c, struct config_usb_cfg, c);
+		if (list_empty(&amp;cfg-&gt;func_list)) {
+			pr_err("Config %s/%d of %s needs atleast one function.\n",
+			      c-&gt;label, c-&gt;bConfigurationValue,
+			      gi-&gt;composite.name);
+			goto err_comp_cleanup;
+		}
+	}
+
+	/* init all strings */
+	if (!list_empty(&amp;gi-&gt;string_list)) {
+		struct gadget_strings *gs;
+
+		i =3D 0;
+		list_for_each_entry(gs, &amp;gi-&gt;string_list, list) {
+
+			gi-&gt;gstrings[i] =3D &amp;gs-&gt;stringtab_dev;
+			gs-&gt;stringtab_dev.strings =3D gs-&gt;strings;
+			gs-&gt;strings[USB_GADGET_MANUFACTURER_IDX].s =3D
+				gs-&gt;manufacturer;
+			gs-&gt;strings[USB_GADGET_PRODUCT_IDX].s =3D gs-&gt;product;
+			gs-&gt;strings[USB_GADGET_SERIAL_IDX].s =3D gs-&gt;serialnumber;
+			i++;
+		}
+		gi-&gt;gstrings[i] =3D NULL;
+		s =3D usb_gstrings_attach(&amp;gi-&gt;cdev, gi-&gt;gstrings,
+				USB_GADGET_FIRST_AVAIL_IDX);
+		if (IS_ERR(s))
+			goto err_comp_cleanup;
+
+		gi-&gt;cdev.desc.iManufacturer =3D s[USB_GADGET_MANUFACTURER_IDX].id;
+		gi-&gt;cdev.desc.iProduct =3D s[USB_GADGET_PRODUCT_IDX].id;
+		gi-&gt;cdev.desc.iSerialNumber =3D s[USB_GADGET_SERIAL_IDX].id;
+	}
+
+	/* Go through all configs, attach all functions */
+	list_for_each_entry(c, &amp;gi-&gt;cdev.configs, list) {
+		struct config_usb_cfg *cfg;
+		struct usb_function *f;
+		struct usb_function *tmp;
+		struct gadget_config_name *cn;
+
+		cfg =3D container_of(c, struct config_usb_cfg, c);
+		if (!list_empty(&amp;cfg-&gt;string_list)) {
+			i =3D 0;
+			list_for_each_entry(cn, &amp;cfg-&gt;string_list, list) {
+				cfg-&gt;gstrings[i] =3D &amp;cn-&gt;stringtab_dev;
+				cn-&gt;stringtab_dev.strings =3D &amp;cn-&gt;strings;
+				cn-&gt;strings.s =3D cn-&gt;configuration;
+				i++;
+			}
+			cfg-&gt;gstrings[i] =3D NULL;
+			s =3D usb_gstrings_attach(&amp;gi-&gt;cdev, cfg-&gt;gstrings, 1);
+			if (IS_ERR(s))
+				goto err_comp_cleanup;
+			c-&gt;iConfiguration =3D s[0].id;
+		}
+
+		list_for_each_entry_safe(f, tmp, &amp;cfg-&gt;func_list, list) {
+			list_del(&amp;f-&gt;list);
+			ret =3D usb_add_function(c, f);
+			if (ret)
+				goto err_purge_funcs;
+		}
+		usb_ep_autoconfig_reset(cdev-&gt;gadget);
+	}
+	usb_ep_autoconfig_reset(cdev-&gt;gadget);
+	return 0;
+
+err_purge_funcs:
+	purge_configs_funcs(gi);
+err_comp_cleanup:
+	composite_dev_cleanup(cdev);
+	return ret;
+}
+
+static void configfs_composite_unbind(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev;
+	struct gadget_info		*gi;
+
+	/* the gi-&gt;lock is hold by the caller */
+
+	cdev =3D get_gadget_data(gadget);
+	gi =3D container_of(cdev, struct gadget_info, cdev);
+
+	purge_configs_funcs(gi);
+	composite_dev_cleanup(cdev);
+	usb_ep_autoconfig_reset(cdev-&gt;gadget);
+	cdev-&gt;gadget =3D NULL;
+	set_gadget_data(gadget, NULL);
+}
+
+static const struct usb_gadget_driver configfs_driver_template =3D {
+	.bind           =3D configfs_composite_bind,
+	.unbind         =3D configfs_composite_unbind,
+
+	.setup          =3D composite_setup,
+	.disconnect     =3D composite_disconnect,
+
+	.max_speed	=3D USB_SPEED_SUPER,
+	.driver =3D {
+		.owner          =3D THIS_MODULE,
+		.name		=3D "configfs-gadget",
+	},
+};
+
+static struct config_group *gadgets_make(
+		struct config_group *group,
+		const char *name)
+{
+	struct gadget_info *gi;
+
+	gi =3D kzalloc(sizeof(*gi), GFP_KERNEL);
+	if (!gi)
+		return ERR_PTR(-ENOMEM);
+
+	gi-&gt;group.default_groups =3D gi-&gt;default_groups;
+	gi-&gt;group.default_groups[0] =3D &amp;gi-&gt;functions_group;
+	gi-&gt;group.default_groups[1] =3D &amp;gi-&gt;configs_group;
+	gi-&gt;group.default_groups[2] =3D &amp;gi-&gt;strings_group;
+
+	config_group_init_type_name(&amp;gi-&gt;functions_group, "functions",
+			&amp;functions_type);
+	config_group_init_type_name(&amp;gi-&gt;configs_group, "configs",
+			&amp;config_desc_type);
+	config_group_init_type_name(&amp;gi-&gt;strings_group, "strings",
+			&amp;gadget_strings_strings_type);
+
+	gi-&gt;composite.bind =3D configfs_do_nothing;
+	gi-&gt;composite.unbind =3D configfs_do_nothing;
+	gi-&gt;composite.suspend =3D NULL;
+	gi-&gt;composite.resume =3D NULL;
+	gi-&gt;composite.max_speed =3D USB_SPEED_SUPER;
+
+	mutex_init(&amp;gi-&gt;lock);
+	INIT_LIST_HEAD(&amp;gi-&gt;string_list);
+	INIT_LIST_HEAD(&amp;gi-&gt;available_func);
+
+	composite_init_dev(&amp;gi-&gt;cdev);
+	gi-&gt;cdev.desc.bLength =3D USB_DT_DEVICE_SIZE;
+	gi-&gt;cdev.desc.bDescriptorType =3D USB_DT_DEVICE;
+	gi-&gt;cdev.desc.bcdDevice =3D cpu_to_le16(get_default_bcdDevice());
+
+	gi-&gt;composite.gadget_driver =3D configfs_driver_template;
+
+	gi-&gt;composite.gadget_driver.function =3D kstrdup(name, GFP_KERNEL);
+	gi-&gt;composite.name =3D gi-&gt;composite.gadget_driver.function;
+
+	if (!gi-&gt;composite.gadget_driver.function)
+		goto err;
+
+#ifdef CONFIG_USB_OTG
+	gi-&gt;otg.bLength =3D sizeof(struct usb_otg_descriptor);
+	gi-&gt;otg.bDescriptorType =3D USB_DT_OTG;
+	gi-&gt;otg.bmAttributes =3D USB_OTG_SRP | USB_OTG_HNP;
+#endif
+
+	config_group_init_type_name(&amp;gi-&gt;group, name,
+				&amp;gadget_root_type);
+	return &amp;gi-&gt;group;
+err:
+	kfree(gi);
+	return ERR_PTR(-ENOMEM);
+}
+
+static void gadgets_drop(struct config_group *group, struct config_item *i=
tem)
+{
+	config_item_put(item);
+}
+
+static struct configfs_group_operations gadgets_ops =3D {
+	.make_group     =3D &amp;gadgets_make,
+	.drop_item      =3D &amp;gadgets_drop,
+};
+
+static struct config_item_type gadgets_type =3D {
+	.ct_group_ops   =3D &amp;gadgets_ops,
+	.ct_owner       =3D THIS_MODULE,
+};
+
+static struct configfs_subsystem gadget_subsys =3D {
+	.su_group =3D {
+		.cg_item =3D {
+			.ci_namebuf =3D "usb_gadget",
+			.ci_type =3D &amp;gadgets_type,
+		},
+	},
+	.su_mutex =3D __MUTEX_INITIALIZER(gadget_subsys.su_mutex),
+};
+
+static int __init gadget_cfs_init(void)
+{
+	int ret;
+
+	config_group_init(&amp;gadget_subsys.su_group);
+
+	ret =3D configfs_register_subsystem(&amp;gadget_subsys);
+	return ret;
+}
+module_init(gadget_cfs_init);
+
+static void __exit gadget_cfs_exit(void)
+{
+	configfs_unregister_subsystem(&amp;gadget_subsys);
+}
+module_exit(gadget_cfs_exit);
diff --git a/drivers/usb/gadget/f_acm.c b/drivers/usb/gadget/f_acm.c
index 52a4ef1..ad4e132 100644
--- a/drivers/usb/gadget/f_acm.c
+++ b/drivers/usb/gadget/f_acm.c
@@ -761,6 +761,59 @@ static struct usb_function *acm_alloc_func(struct usb_=
function_instance *fi)
 	return &amp;acm-&gt;port.func;
 }
=20
+static inline struct f_serial_opts *to_f_serial_opts(struct config_item *i=
tem)
+{
+	return container_of(to_config_group(item), struct f_serial_opts,
+			func_inst.group);
+}
+
+CONFIGFS_ATTR_STRUCT(f_serial_opts);
+static ssize_t f_acm_attr_show(struct config_item *item,
+				 struct configfs_attribute *attr,
+				 char *page)
+{
+	struct f_serial_opts *opts =3D to_f_serial_opts(item);
+	struct f_serial_opts_attribute *f_serial_opts_attr =3D
+		container_of(attr, struct f_serial_opts_attribute, attr);
+	ssize_t ret =3D 0;
+
+	if (f_serial_opts_attr-&gt;show)
+		ret =3D f_serial_opts_attr-&gt;show(opts, page);
+	return ret;
+}
+
+static void acm_attr_release(struct config_item *item)
+{
+	struct f_serial_opts *opts =3D to_f_serial_opts(item);
+
+	usb_put_function_instance(&amp;opts-&gt;func_inst);
+}
+
+static struct configfs_item_operations acm_item_ops =3D {
+	.release                =3D acm_attr_release,
+	.show_attribute		=3D f_acm_attr_show,
+};
+
+static ssize_t f_acm_port_num_show(struct f_serial_opts *opts, char *page)
+{
+	return sprintf(page, "%u\n", opts-&gt;port_num);
+}
+
+static struct f_serial_opts_attribute f_acm_port_num =3D
+	__CONFIGFS_ATTR_RO(port_num, f_acm_port_num_show);
+
+
+static struct configfs_attribute *acm_attrs[] =3D {
+	&amp;f_acm_port_num.attr,
+	NULL,
+};
+
+static struct config_item_type acm_func_type =3D {
+	.ct_item_ops    =3D &amp;acm_item_ops,
+	.ct_attrs	=3D acm_attrs,
+	.ct_owner       =3D THIS_MODULE,
+};
+
 static void acm_free_instance(struct usb_function_instance *fi)
 {
 	struct f_serial_opts *opts;
@@ -784,6 +837,8 @@ static struct usb_function_instance *acm_alloc_instance=
(void)
 		kfree(opts);
 		return ERR_PTR(ret);
 	}
+	config_group_init_type_name(&amp;opts-&gt;func_inst.group, "",
+			&amp;acm_func_type);
 	return &amp;opts-&gt;func_inst;
 }
 DECLARE_USB_FUNCTION_INIT(acm, acm_alloc_instance, acm_alloc_func);
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index 3c671c1..3c4aac6 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -39,6 +39,7 @@
 #include &lt;linux/usb/ch9.h&gt;
 #include &lt;linux/usb/gadget.h&gt;
 #include &lt;linux/log2.h&gt;
+#include &lt;linux/configfs.h&gt;
=20
 /*
  * USB function drivers should return USB_GADGET_DELAYED_STATUS if they
@@ -463,6 +464,8 @@ struct usb_function_driver {
 };
=20
 struct usb_function_instance {
+	struct config_group group;
+	struct list_head cfs_list;
 	struct usb_function_driver *fd;
 	void (*free_func_inst)(struct usb_function_instance *inst);
 };
diff --git a/include/linux/usb/gadget_configfs.h b/include/linux/usb/gadget=
_configfs.h
new file mode 100644
index 0000000..d74c0ae
--- /dev/null
+++ b/include/linux/usb/gadget_configfs.h
@@ -0,0 +1,110 @@
+#ifndef __GADGET_CONFIGFS__
+#define __GADGET_CONFIGFS__
+
+#include &lt;linux/configfs.h&gt;
+
+int check_user_usb_string(const char *name,
+		struct usb_gadget_strings *stringtab_dev);
+
+#define GS_STRINGS_W(__struct, __name)	\
+	static ssize_t __struct##_##__name##_store(struct __struct *gs, \
+		const char *page, size_t len)		\
+{							\
+	int ret;					\
+							\
+	ret =3D usb_string_copy(page, &amp;gs-&gt;__name);	\
+	if (ret)					\
+		return ret;				\
+	return len;					\
+}
+
+#define GS_STRINGS_R(__struct, __name)	\
+	static ssize_t __struct##_##__name##_show(struct __struct *gs, \
+			char *page)	\
+{	\
+	return sprintf(page, "%s\n", gs-&gt;__name ?: "");	\
+}
+
+#define GS_STRING_ITEM_ATTR(struct_name, name)	\
+	static struct struct_name##_attribute struct_name##_##name =3D \
+		__CONFIGFS_ATTR(name,  S_IRUGO | S_IWUSR,		\
+				struct_name##_##name##_show,		\
+				struct_name##_##name##_store)
+
+#define GS_STRINGS_RW(struct_name, _name)	\
+	GS_STRINGS_R(struct_name, _name)	\
+	GS_STRINGS_W(struct_name, _name)	\
+	GS_STRING_ITEM_ATTR(struct_name, _name)
+
+#define USB_CONFIG_STRING_RW_OPS(struct_in)				\
+	CONFIGFS_ATTR_OPS(struct_in);					\
+									\
+static struct configfs_item_operations struct_in##_langid_item_ops =3D {	\
+	.release                =3D struct_in##_attr_release,		\
+	.show_attribute         =3D struct_in##_attr_show,		\
+	.store_attribute        =3D struct_in##_attr_store,		\
+};									\
+									\
+static struct config_item_type struct_in##_langid_type =3D {		\
+	.ct_item_ops	=3D &amp;struct_in##_langid_item_ops,			\
+	.ct_attrs	=3D struct_in##_langid_attrs,			\
+	.ct_owner	=3D THIS_MODULE,					\
+}
+
+#define USB_CONFIG_STRINGS_LANG(struct_in, struct_member)	\
+	static struct config_group *struct_in##_strings_make(		\
+			struct config_group *group,			\
+			const char *name)				\
+	{								\
+	struct struct_member *gi;					\
+	struct struct_in *gs;						\
+	struct struct_in *new;						\
+	int langs =3D 0;							\
+	int ret;							\
+									\
+	new =3D kzalloc(sizeof(*new), GFP_KERNEL);			\
+	if (!new)							\
+		return ERR_PTR(-ENOMEM);				\
+									\
+	ret =3D check_user_usb_string(name, &amp;new-&gt;stringtab_dev);		\
+	if (ret)							\
+		goto err;						\
+	config_group_init_type_name(&amp;new-&gt;group, name,			\
+			&amp;struct_in##_langid_type);			\
+									\
+	gi =3D container_of(group, struct struct_member, strings_group);	\
+	ret =3D -EEXIST;							\
+	list_for_each_entry(gs, &amp;gi-&gt;string_list, list) {		\
+		if (gs-&gt;stringtab_dev.language =3D=3D new-&gt;stringtab_dev.language)=
 \
+			goto err;					\
+		langs++;						\
+	}								\
+	ret =3D -EOVERFLOW;						\
+	if (langs &gt;=3D MAX_USB_STRING_LANGS)				\
+		goto err;						\
+									\
+	list_add_tail(&amp;new-&gt;list, &amp;gi-&gt;string_list);			\
+	return &amp;new-&gt;group;						\
+err:									\
+	kfree(new);							\
+	return ERR_PTR(ret);						\
+}									\
+									\
+static void struct_in##_strings_drop(					\
+		struct config_group *group,				\
+		struct config_item *item)				\
+{									\
+	config_item_put(item);						\
+}									\
+									\
+static struct configfs_group_operations struct_in##_strings_ops =3D {	\
+	.make_group     =3D &amp;struct_in##_strings_make,			\
+	.drop_item      =3D &amp;struct_in##_strings_drop,			\
+};									\
+									\
+static struct config_item_type struct_in##_strings_type =3D {		\
+	.ct_group_ops   =3D &amp;struct_in##_strings_ops,			\
+	.ct_owner       =3D THIS_MODULE,					\
+}
+
+#endif
--=20
1.7.10.4

--
To unsubscribe from this list: send the line "unsubscribe linux-usb" in
the body of a message to majordomo@xxxxxxxxxxxxxxx
More majordomo info at  <a rel=3D"nofollow" href=3D"http://vger.kernel.org/=
majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a>

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name=3D"77428" href=3D"https://www.spinics.net/lists/linux-u=
sb/msg77428.html">Re: [PATCH 30/30] usb/gadget: the start of the configfs i=
nterface</a></strong>
<ul><li><em>From:</em> Felipe Balbi</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name=3D"76378" href=3D"https://www.spinics.net/lists/linux-u=
sb/msg76378.html">my pending queue including configfs for the gadgets</a></=
strong>
<ul><li><em>From:</em> Sebastian Andrzej Siewior</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href=3D"https://www.spinics.net/lists/linux-usb/msg76387.html">[=
PATCH 17/30] usb/gadget: nokia: use function framework for ACM</a></strong>
</li>
<li>Next by Date:
<strong><a href=3D"https://www.spinics.net/lists/linux-usb/msg76389.html">[=
PATCH 13/30] usb/gadget: convert f_acm to new function interface with backw=
ards compatibility</a></strong>
</li>
<li>Previous by thread:
<strong><a href=3D"https://www.spinics.net/lists/linux-usb/msg78752.html">[=
PATCH v2 corrected] usb/gadget: nokia: use function framework for ACM</a></=
strong>
</li>
<li>Next by thread:
<strong><a href=3D"https://www.spinics.net/lists/linux-usb/msg77428.html">R=
e: [PATCH 30/30] usb/gadget: the start of the configfs interface</a></stron=
g>
</li>
<li>Index(es):
<ul>
<li><a href=3D"https://www.spinics.net/lists/linux-usb/mail184.html#76388">=
<strong>Date</strong></a></li>
<li><a href=3D"https://www.spinics.net/lists/linux-usb/thrd183.html#76388">=
<strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<center>
<font size=3D"-1">
<a href=3D"https://www.spinics.net/lists/">[Index&nbsp;of&nbsp;Archives]</a=
>
&nbsp;
&nbsp;
<a href=3D"https://www.spinics.net/lists/linux-media/">[Linux&nbsp;Media]</=
a>
&nbsp;
&nbsp;
<a href=3D"https://www.spinics.net/lists/linux-input/">[Linux&nbsp;Input]</=
a>
&nbsp;
&nbsp;
<a href=3D"https://www.spinics.net/lists/linux-audio-users/">[Linux&nbsp;Au=
dio&nbsp;Users]</a>
&nbsp;
&nbsp;
<a href=3D"https://yosemitenews.info/">[Yosemite&nbsp;News]</a>
&nbsp;
&nbsp;
<a href=3D"https://www.spinics.net/lists/kernel/">[Linux&nbsp;Kernel]</a>
&nbsp;
&nbsp;
<a href=3D"https://www.spinics.net/lists/linux-scsi/">[Linux&nbsp;SCSI]</a>
&nbsp;
&nbsp;
<a href=3D"https://www.spinics.net/lists/linux-usb-devel/">[Old&nbsp;Linux&=
nbsp;USB&nbsp;Devel&nbsp;Archive]</a>
</font>
</center>
<hr>
<p>
</p><div>

<ins class=3D"adsbygoogle" style=3D"display:block" data-ad-format=3D"autore=
laxed" data-ad-client=3D"ca-pub-3422782820843221" data-ad-slot=3D"142452456=
4"></ins>

</div>
<table width=3D"100%">
<tbody><tr>
<td align=3D"left">&nbsp;</td>
<td align=3D"right"><a href=3D"https://www.spinics.net/lists/"><img src=3D"=
https://www.spinics.net/button_01.gif" border=3D"0" alt=3D"Powered by Linux=
"></a></td>
</tr>
</tbody></table>
<!--X-User-Footer-End-->





</body></html>
------MultipartBoundary--ArzVZrXEILSAOfWYeUefhfpv5l7ZR3rZdqEfzbYOA1----
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: https://www.google.com/cse/static/images/1x/googlelogo_lightgrey_46x16dp.png

iVBORw0KGgoAAAANSUhEUgAAAC4AAAAQCAQAAADDwIVhAAAB7klEQVR4AdWUA7BWURSF+5Ft27Zt
27ZtW4Ns29aX7Rpl1yDbrrvbc6Zn+73LhXvWPY4U8Q9i0pQtnGUTdYgZwLIOSlEYu092Hm7wgwOs
4RACAQyPwWm2EdV7MxaPuEZBoimORlHKBTA8OodY51N4L/5QxlvHqQVtrsymzOnOjUI0j+HYiInN
Y8QJzhPHoITkIbc5YxGXRYieL2lhvBaKBEvVuMoycxzhK6d4TwHQcAcNzRdf6Ok+/BqHcZr/9kPM
+ZXK7OIvrSnBfISaeoqiEqr8VScG57lDdapwGaEo+1hJcSxWkJ3ZCB3cwjdyi1QGxSMLmSiM0J8v
TP/vv2CDni/+s+nqdEIjDauHUETDF7FM9Roc4A/nKO0WXgahh9tUYhAvacY3Rv3n99ip573/bJQ6
/REyGFYBy4QvZD3CDzaQ0dM8VUuYQFFT63EIU01nPSE/SeiI0E1PUZRElSdcJQ2P2ElGfW/6X/Pl
1EGYSQwyM4MCHmfqEP7yg1f8QhhoRj4zd7B4gjAPh57zEGWWqpnUrc4P3vKaFwhFOckOojAC4Skf
eU4ur+usPO2oSBQPK681qVx5KmWlcPxn0WhIOdogZCSRnjbVUtKSykHfLLaxgmQkZzevgn8vqs9r
PvCe51QK/nAb8SlEERL6/M0/SoB55gUBIU8AAAAASUVORK5CYII=

------MultipartBoundary--ArzVZrXEILSAOfWYeUefhfpv5l7ZR3rZdqEfzbYOA1----
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: https://www.spinics.net/button_01.gif

R0lGODlhWAAfAMQAAP///wgICEJCQlJSUlpaWmtra3Nzc4SEhJSUlK2trb29vc7Ozt7e3loAALVC
APdrAP+MANbGraV7Oe/GMf/eAFqEcxghIQC1/zm17wCU/zmU3iGM9wBj5ylavQA5vQAAACwAAAAA
WAAfAAAF/yAgjmRpnmiqrmw6tHAsz6vxiUuu73zv/8CgcKfAaDTBzw2wUCh8z2hTJ61OrdirNvvk
YS6YcAaoxA3P6PRZwbmAv5xfmalj2O3qvP6n8GTcbhwMPnM6BQFKHxYIPQwWAV17klBtFx5uY4RL
dQxKAXg8nR8Jg5OmOx8CFx+YSD2FOXaIBKA7DAkJp7o6Hh5hrZpmCwwAswCltnfKy4PNeM7Qy3ls
EhAUFW4YVDqwwwyztZwIyuMLBgLjdgLrCrfrAgwKBAgIBwoF77loCgIPFP8TMrji0Y0YOGSxCigZ
RECJgkQf0i1Qku7hBzsWDRwLYCHSmQgO/v17cGFDMCZPZP99oIUwR4IydpQIUADg5cVjDdMBWGjn
ZYCaAYapUdDAHwUHBS7EebUp1reV4bwhGoGIGDGYAAaMujPVTtYPNki1HOLBggMHlzKYZCrMIFSE
d3gWu2G1KwOtCI7NXSbz2NggSjn0+nNBIFs6UlceSzZXxFO/jYk1FLsXso2fUYN8KQwIUwZtqJoO
m8vSWYJ2XffWvclgsmO7gz4gKpCZzx8MJjDcDt32KQG/dyxcpRt5uF6tpESk7jROibceCexRIYyC
w4YLyAqSdmzHwKenxCJvJN5QgIgDC3GaB4BA9p1QA/Qt2PAZ94kFlbiJjq2EgIABWoE1HDETfUBT
TAYCoID/TTIhEgACWo0migCnlXKLPKTkQJh9uWWjnzCHyIYIRB8MI4AFA+BjwSMCGHCABScuksAA
CFjwwQEAWGDPOQFQ6F+PFrhoAEMJIEBhKRy0wSEJumXgQQcfIuYNM1QyQE9NtBAwWgGk0ALATLcw
YIATBJDCpYIIODHTAemUOQgGA0iAzZIAfCGABAIsVSAOXVRZyx30qMMAPHYEymYCBiCQyz1OpFRA
O/UsmIubrekTgVEVZJDBCBEMwIE/BejZjRoMsCkooaWSogCNCwhwQDwD3NGOmwgMiRGlbi4wwQMP
QDABB5+NAEGvEHQg6iYenVHqq9EtO8gA3sR3l1gtRtdloYauIrpAAlouIG0OvfYaAQkMTAABBBJw
MNCoaAwC4QEHeFOrdMMwYqU3Chjg5j3x3lLAo4McQAC8GebgAK8DbBAeBgZAgJYH8rErVDNCTWyH
qX5mrHHGOkRQ1MO9cCCAwx4MtCcTGzOzQKDApeyynzxMIEEHNNOMwAPyRXlKsrukEU4EEiwQAUE3
KETi0UgnrfTSTDftNEQNPS311FRXfXQIADs=

------MultipartBoundary--ArzVZrXEILSAOfWYeUefhfpv5l7ZR3rZdqEfzbYOA1------
